import { Kafka, KafkaMessage } from 'kafkajs';
import { Pool } from 'pg';

const ADVISOR_RESULTS_TOPIC = process.env.ADVISOR_RESULTS_TOPIC || 'platform.engine.results';
const BOOTSTRAP_SERVER = (process.env.KAFKA_HOST || 'ts_platform_mock') + ':' + (process.env.KAFKA_PORT || '9092');
const GROUP_ID = process.env.KAFKA_GROUP_ID || 'vulnerability';

const DB_NAME = process.env.POSTGRESQL_DATABASE || 'vulnerability';
const DB_USER = process.env.POSTGRESQL_USER || 've_db_user_unknown';
const DB_PASS = process.env.POSTGRESQL_PASSWORD || 've_db_user_unknown_pwd';
const DB_HOST = process.env.POSTGRESQL_HOST || 've_database';
const DB_PORT = Number(process.env.POSTGRESQL_PORT || '5432');

const RULE_BLACKLIST = ['CVE_2017_5715_cpu_virt|VIRT_CVE_2017_5715_CPU_3_ONLYKERNEL', 'CVE_2017_5715_cpu_virt'];

const pool = new Pool({
    host: DB_HOST,
    user: DB_USER,
    database: DB_NAME,
    password: DB_PASS,
    port: DB_PORT,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
});

const kafka = new Kafka({
    clientId: 'ts_advisor_listener',
    brokers: [BOOTSTRAP_SERVER],
});

const consumer = kafka.consumer({ groupId: GROUP_ID });

const initRuleCache = async (): Promise<Record<string, string>> => {
    const client = await pool.connect();
    const res = await client.query('SELECT id, name FROM insights_rule');
    client.release();
    const retval = Object();
    res.rows.forEach((item) => {
        retval[item.name] = Number(item.id);
    });
    return retval;
};

const initCveCache = async (): Promise<Record<string, string>> => {
    const client = await pool.connect();
    const res = await client.query('SELECT id, cve FROM cve_metadata');
    client.release();
    const retval = Object();
    res.rows.forEach((item) => {
        retval[item.cve] = Number(item.id);
    });
    return retval;
};

const initAccountCache = async (): Promise<Record<string, string>> => {
    const client = await pool.connect();
    const rest = await client.query('SELECT id, name FROM rh_account');
    client.release();
    const retval = Object();
    rest.rows.forEach((item) => {
        retval[item.name] = Number(item.id);
    });
    return retval;
};

let RULE_CACHE: Record<string, string>;
let CVE_CACHE: Record<string, string>;
let ACCOUNT_CACHE: Record<string, string>;

const importCve = async (cve: string) => {
    const client = await pool.connect();
    const res = await client.query(
        'INSERT INTO cve_metadata (cve, description, impact_id) VALUES ($1, $2, $3) ' + 'ON CONFLICT (cve) DO UPDATE SET cve = $4 RETURNING id AS inserted',
        [cve, 'unknown', 0, cve]
    );
    CVE_CACHE[cve] = res.rows[0].inserted;
    client.release();
};

const importRule = async (rule: string, cves: Array<string>, ruleOnly = false) => {
    const client = await pool.connect();
    const res = await client.query(
        'INSERT INTO insights_rule (name, rule_only) VALUES($1, $2) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name,' +
            ' rule_only = EXCLUDED.rule_only RETURNING id AS inserted',
        [rule, ruleOnly]
    );
    RULE_CACHE[rule] = res.rows[0].inserted;
    cves.forEach(async (cve) => {
        if (!(cve in CVE_CACHE)) {
            await importCve(cve);
        }
        client.query('INSERT INTO cve_rule_mapping (rule_id, cve_id) VALUES ($1, $2) ON CONFLICT DO NOTHING', [RULE_CACHE[rule], CVE_CACHE[cve]]);
    });
    client.release();
};

const importSystemData = async (systemData) => {
    const client = await pool.connect();
    if (!(systemData.rh_account in ACCOUNT_CACHE)) {
        const res = await client.query(
            'INSERT INTO rh_account (name) VALUES ($1) ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name RETURNING id AS inserted',
            [systemData.rh_account]
        );
        ACCOUNT_CACHE[systemData.rh_account] = res.rows[0].inserted;
        // prometheus
    }
    const res = await client.query(
        'INSERT INTO system_platform (inventory_id, rh_account_id, display_name, advisor_evaluated, stale_timestamp, ' +
            "stale_warning_timestamp, culled_timestamp, stale) VALUES ($1, $2, $3, now(), $4, $5, $6, 'F') ON CONFLICT (inventory_id) DO UPDATE SET " +
            "display_name = $7, advisor_evaluated = now(), stale_timestamp = $8, stale_warning_timestamp = $9, culled_timestamp = $10, stale = 'F' " +
            'RETURNING (xmax = 0) AS inserted, id, when_deleted',
        [
            systemData.inventory_id,
            ACCOUNT_CACHE[systemData.rh_account],
            systemData.display_name,
            systemData.stale_timestamp,
            systemData.stale_warning_timestamp,
            systemData.culled_timestamp,
            systemData.display_name,
            systemData.stale_timestamp,
            systemData.stale_warning_timestamp,
            systemData.culled_timestamp,
        ]
    );

    if (res.rows[0].when_deleted !== null) {
        console.warn('Received recently deleted inventory id: ', systemData.inventory_id);
        return undefined;
    }
    if (res.rows[0].inserted === 1) {
        // prometheus
    } else {
        // prometheus
    }

    client.release();
    return res.rows[0].id;
};

const importRuleHits = async (rhAccountId, inventoryId, systemId, ruleHits) => {
    const client = await pool.connect();
    const activeRes = await client.query("SELECT ir.id FROM insights_rule ir WHERE ir.active = 'T'");

    const activeRules = new Set();
    activeRes.rows.forEach((item) => {
        activeRules.add(Number(item.id));
    });

    const systemVulnerabilities = await client.query(
        'SELECT sv.id, sv.cve_id, sv.rule_id, sv.when_mitigated, cm.cve FROM system_vulnerabilities sv JOIN cve_metadata cm ON sv.cve_id = cm.id ' +
            'WHERE system_id = $1 AND rh_account_id = $2',
        [systemId, rhAccountId]
    );

    const ruleHitsCveIds = Object.keys(ruleHits).map((item) => Number(item));
    const systemCves = [];
    const toUpdate = [];

    systemVulnerabilities.rows.forEach((item) => {
        if (ruleHitsCveIds.includes(item.cve_id)) {
            if ('mitigation_reason' in ruleHits[item.cve_id]) {
                if (!activeRules.has(ruleHits[item.cve_id].id) && item.when_mitigated === null) {
                    systemCves.push(item.cve);
                }
                toUpdate.push([item.row_id, rhAccountId, ruleHits[item.cve_id].id, null, ruleHits[item.cve_id].mitigation_reason]);
            } else {
                if (activeRules.has(ruleHits[item.cve_id].id) || item.when_mitigated === null) {
                    systemCves.push(item.cve);
                }
                toUpdate.push([item.row_id, rhAccountId, ruleHits[item.cve_id].id, ruleHits[item.cve_id].details, null]);
            }
            delete ruleHits[item.cve_id];
        } else if (item.rule_id !== null) {
            if (item.when_mitigated === null) {
                systemCves.push(item.cve);
            }
        } else if (item.when_mitigated === null) {
            systemCves.push(item.cve);
        }
    });

    Object.keys(ruleHits).forEach((cveId) => {
        client.query(
            'INSERT INTO system_vulnerabilities (rh_account_id, system_id, cve_id, rule_id, rule_hit_details, mitigation_reason, when_mitigated) ' +
                'values ($1, $2, $3, $4, $5, $6, now())',
            [rhAccountId, systemId, cveId, ruleHits[cveId].id, ruleHits[cveId]?.details, ruleHits[cveId]?.mitigation_reason]
        );
        if (ruleHits[cveId].id in activeRules && 'details' in ruleHits[cveId]) {
            systemCves.push(ruleHits[cveId].cve_name);
        }
    });
    toUpdate.forEach((item) => {
        client.query(
            'UPDATE system_vulnerabilities AS sv SET rule_id = $3, rule_hit_details = $4, mitigation_reason = $5 WHERE id = $1 and rh_account_id = $2',
            item
        );
    });
    client.release();
};

const importSystem = async (systemData, ruleHits): Promise<boolean> => {
    const systemId = await importSystemData(systemData);
    if (systemId === undefined) {
        return false;
    }
    importRuleHits(ACCOUNT_CACHE[systemData.rh_account], systemData.inventory_id, Number(systemId), ruleHits);
    return true;
};

const processMessage = async (msg: KafkaMessage) => {
    console.log('Processing message');
    let msgObj;
    try {
        msgObj = JSON.parse(msg.value.toString());
    } catch (e) {
        console.error('Can not parse JSON');
        return;
    }
    if (msgObj?.input?.platform_metadata?.b64_identity === undefined) {
        console.error('Missing identity');
    }
    let identity: string;
    try {
        identity = Buffer.from(msgObj.input.platform_metadata.b64_identity, 'base64').toString();
    } catch (e) {
        console.error('Can not parse identity');
        console.error(e);
        return;
    }

    const systemData = {
        rh_account: msgObj?.input?.host?.account,
        display_name: msgObj?.input?.host?.display_name,
        inventory_id: msgObj?.input?.host?.id,
        stale_timestamp: msgObj?.input?.host?.stale_timestamp,
        stale_warning_timestamp: msgObj?.input?.host?.stale_warning_timestamp,
        culled_timestamp: msgObj?.input?.host?.culled_timestamp,
    };

    const reports = msgObj.results.reports;
    const ruleHits = Object();
    reports.forEach((report) => {
        if (report?.details?.cves !== undefined) {
            const rule = report.rule_id;
            if (!(rule in RULE_BLACKLIST)) {
                if (!(rule in RULE_CACHE)) {
                    importRule(rule, Object.keys(report.details.cves));
                }
                Object.keys(report.details.cves).forEach((cve) => {
                    if (!(cve in CVE_CACHE)) {
                        importCve(cve);
                    }
                    if (report.details.cves[cve] === false) {
                        ruleHits[CVE_CACHE[cve]] = {
                            id: RULE_CACHE[rule],
                            details: JSON.stringify(report.details),
                            cve_name: cve,
                        };
                    } else if (typeof report.details.cves[cve] === 'string') {
                        ruleHits[CVE_CACHE[cve]] = {
                            id: RULE_CACHE[rule],
                            mitigation_reason: report.details.cves[cve],
                        };
                    }
                });
            }
        }
    });

    const passes = msgObj.results.pass;
    passes.forEach((pass) => {
        if (pass?.details?.cves !== undefined) {
            const rule = pass.pass_id.split('|')[0];
            if (!(rule in RULE_BLACKLIST)) {
                if (!(rule in RULE_CACHE)) {
                    importRule(rule, Object.keys(pass.details.cves), true);
                }
            }
            Object.keys(pass.details.cves).forEach((cve) => {
                if (!(cve in CVE_CACHE)) {
                    importCve(cve);
                }
                ruleHits[CVE_CACHE[cve]] = {
                    id: RULE_CACHE[rule],
                    mitigation_reason: pass.details.cves[cve],
                };
            });
        }
    });

    await importSystem(systemData, ruleHits);
    console.log('Message processed');
};

const start = async () => {
    await consumer.connect();
    await consumer.subscribe({ topic: ADVISOR_RESULTS_TOPIC, fromBeginning: true });

    RULE_CACHE = await initRuleCache();
    CVE_CACHE = await initCveCache();
    ACCOUNT_CACHE = await initAccountCache();

    await consumer.run({
        eachMessage: async ({ topic, partition, message }) => {
            processMessage(message);
        },
    });
};

if (require.main === module) {
    start();
}
